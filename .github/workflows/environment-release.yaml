name: Apply Pipeline
on:
  workflow_call:
    inputs:
      workload_identity_provider:
        type: string
      service_account:
        type: string
      cluster_name:
        type: string
      cluster_location:
        type: string
      BOT_USER_NAME:
        type: string
      BOT_USER_EMAIL:
        type: string
    secrets:
      BOT_TOKEN:
        description: "Bot token"
        required: true
env:
  JX_KUBERNETES: true
  SOURCE_DIR: "${{ github.workspace }}/source"
  VERSTION_STREAM_ABS_PATH: "${{ github.workspace }}/source/versionStream"
  BOT_USER: ${{ inputs.BOT_USER_NAME }}
  BOT_USER_EMAIL: ${{ inputs.BOT_USER_EMAIL }}

jobs:
  apply:
    # if: ${{ github.actor }} != ${{ inputs.BOT_USER_NAME }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
      pull-requests: write
    defaults:
      run:
        shell: sh
    steps:
      - name: Installing dependencies
        run: |
          curl -L https://github.com/rochana-atapattu/helmfile/releases/download/v0.1001.0/helmfile_0.1001.0_linux_amd64.tar.gz | tar xzv
          chmod +x helmfile 
          mv helmfile /usr/local/bin/helmfile

          curl -L https://github.com/jenkins-x/jx/releases/download/v3.7.7/jx-linux-amd64.tar.gz | tar xzv
          chmod +x jx 
          mv jx /usr/local/bin
      - uses: actions/checkout@v3
        with:
          token: ${{ secrets.BOT_TOKEN }}
          path: "${{ github.workspace }}/source"
          submodules: true
      - name: Setup git credentials
        working-directory: "${{ github.workspace }}/source"
        run: |
          git config --global user.name $BOT_USER
          git config --global user.email $BOT_USER_EMAIL
          git config --global credential.helper store
          git config --global --add safe.directory '*'
          git submodule update --init --recursive
      - name: Get branches with PRs for each submodule
        uses: actions/github-script@v6
        id: get-branches
        with:
          github-token: ${{ secrets.BOT_TOKEN }}
          script: |
            const path = require('path');
            const child_process = require('child_process');

            const workspace = process.env.GITHUB_WORKSPACE;
            const sourceDirectory = path.join(workspace, 'source');

            // Change the current working directory to the cloned directory
            process.chdir(sourceDirectory);
            const urls = child_process.execSync('git config --file .gitmodules --get-regexp url | awk \'{ print $2 }\'').toString().trim().split('\n');

            console.log(`Submodule URLs: ${urls}`);

            // Prepare an object to store the branch names for each submodule
            const submoduleBranches = {};

            // Iterate over each submodule
            for (const url of urls) {
              // Ensure that the URL is not empty
              if (!url) {
                console.log(`Empty URL encountered. Skipping...`);
                continue;
              }

              // Extract the owner and repo from the URL
              const match = url.match(/github.com[:/](.+)\/(.+)\.git/);

              // Ensure that the regular expression matched
              if (!match) {
                console.log(`Could not extract owner and repo from URL: ${url}`);
                continue;
              }

              const [, owner, repo] = match;

              console.log(`Owner: ${owner} Repo: ${repo}`)

              console.log(`Fetching PRs for ${owner}/${repo}`);

              // Get the open PRs to main
              const pullRequests = await github.rest.pulls.list({
                owner,
                repo,
                state: 'open',
                base: 'main',
              });

              // Extract the branch names
              const branchNames = pullRequests.data.map(pr => pr.head.ref);

              console.log(`Branches with PRs: ${branchNames}`);

              // Store the branch names
              submoduleBranches[`${repo}`] = branchNames;
            }

            console.log(`Result: ${JSON.stringify(submoduleBranches)}`);
            console.log(`Type of submoduleBranches: ${typeof submoduleBranches}`);
            console.log(`Value of submoduleBranches: ${JSON.stringify(submoduleBranches)}`);
            const results = JSON.stringify(submoduleBranches)
            return results;
          result-encoding: string

      - name: Checkout branches in each submodule
        working-directory: "${{ github.workspace }}/source"
        shell: bash
        run: |
          branches_json=$(jq -n --argjson obj '${{ steps.get-branches.outputs.result }}' '$obj')
          if [ "$branches_json" == '"[object Object]"' ]; then
            echo "No branches found."
          exit 0
          fi
          for submodule in $(git submodule status | awk '{print $2}'); do
            cd $submodule
            git config remote.origin.fetch +refs/heads/*:refs/remotes/origin/*

            for branch in $(jq -r --arg submodule $submodule '.[$submodule][]' <<<"$branches_json"); do
              git fetch origin $branch
              git checkout -b $branch origin/$branch
            done
            cd ..
          done
      - id: "auth"
        name: "Authenticate to Google Cloud"
        uses: "google-github-actions/auth@v1"
        with:
          token_format: "access_token"
          workload_identity_provider: ${{ inputs.workload_identity_provider }}
          service_account: ${{ inputs.service_account }}
      - id: "get-credentials"
        uses: "google-github-actions/get-gke-credentials@v1"
        with:
          cluster_name: ${{ inputs.cluster_name }}
          location: ${{ inputs.cluster_location }}
          use_connect_gateway: "true"
      - uses: "docker/login-action@v1"
        with:
          registry: "us-docker.pkg.dev" # or REGION-docker.pkg.dev
          username: "oauth2accesstoken"
          password: "${{ steps.auth.outputs.access_token }}"
      - uses: actions/cache@v3
        with:
          path: "${{ github.workspace }}/.cache"
          key: ${{ runner.os }}-helmfile-${{ github.run_id }}
          restore-keys: |
            ${{ runner.os }}-helmfile-
      - name: make-apply
        working-directory: "${{ github.workspace }}/source"
        run: make apply
        env:
          HELMFILE_CACHE_HOME: "${{ github.workspace }}/.cache"
          GITHUB_ACTOR: ${{ inputs.BOT_USER_NAME }}
          GITHUB_TOKEN: ${{ secrets.BOT_TOKEN }}
